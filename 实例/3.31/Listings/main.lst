C51 COMPILER V9.60.7.0   MAIN                                                              04/01/2025 17:23:36 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE code\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          // https://www.4t.wiki/exercise/7d88509d740668ecceaf34308a093aac
   2          
   3          #include "main.h"
   4          
   5          extern uchar led_value[8];
   6          extern uchar seg[8];
   7          
   8          
   9          enum {
  10              KEY_TIME = 15,
  11              STATE_TIME = 20,
  12              SONIC_TIME = 900,
  13              ADC_TIME = 90,
  14              SHAN_TIME = 100
  15          };
  16          
  17          
  18          
  19          // pcf8591
  20          uchar ADC_value;
  21          uint ADC_time;
  22          
  23          // led
  24          uint shan_time;
  25          bit shan_flag;
  26          
  27          // seg
  28          struct {
  29              uchar time;
  30              uchar mode_1;
  31              uchar mode_2;
  32              
  33              // 旋钮模式选择调整上限还是下限  
  34              // 0为下限 1 为上限
  35              uchar check_mode2;
  36              uchar one_flag;
  37          } state;
  38          
  39          
  40          // 参数变量
  41          struct {
  42              char low_value;
  43              char high_value;
  44              uchar out_times;
  45          } argument;
  46          
  47          
  48          // key
  49          struct {
  50              uchar time;
  51              uchar press;
  52          } key;
  53          
  54          
C51 COMPILER V9.60.7.0   MAIN                                                              04/01/2025 17:23:36 PAGE 2   

  55          // 继电器
  56          
  57          
  58          // sonic
  59          struct {
  60              uchar distance;
  61              uint time;
  62              uchar list[3];
  63          } sonic;
  64          
  65          void main()
  66          {
  67   1        
  68   1          boot_init();
  69   1          led_state();
  70   1      
  71   1      
  72   1          state.one_flag = 99;
  73   1          argument.high_value = 60;
  74   1          argument.low_value = 10;
  75   1         
  76   1      
  77   1          while (1)
  78   1          {
  79   2              if (key.time == KEY_TIME)
  80   2              {
  81   3                  key_proc();
  82   3                  key.time = 0;
  83   3              }
  84   2      
  85   2              if (state.time == STATE_TIME)
  86   2              {
  87   3                  state_proc();
  88   3                  state.time = 0;
  89   3              }
  90   2      
  91   2              if (sonic.time == SONIC_TIME)
  92   2              {
  93   3                  sonic_proc();
  94   3                  sonic.time = 0;
  95   3              }
  96   2      
  97   2              if (ADC_time == ADC_TIME )
  98   2              {
  99   3                  if (state.mode_2 == 1)
 100   3                      ADC_proc();
 101   3                  ADC_time = 0;
 102   3              }
 103   2      
 104   2              if (shan_time == SHAN_TIME)
 105   2              {
 106   3                  if (shan_flag == 1)
 107   3                  {
 108   4                      shan_flag = 0;
 109   4                  }
 110   3                  else
 111   3                  {
 112   4                      shan_flag = 1;
 113   4                  }
 114   3                  shan_time = 0;
 115   3              }
 116   2          }
C51 COMPILER V9.60.7.0   MAIN                                                              04/01/2025 17:23:36 PAGE 3   

 117   1      }
 118          
 119          
 120          void Timer2_Isr(void) interrupt 12
 121          {
 122   1          static uint i;
 123   1          i++;
 124   1          if (i > 30000) { i = 0; }
 125   1      
 126   1          seg_display();
 127   1          if (i % 1 == 0)
 128   1              led_display();
 129   1              adjust_out();
 130   1      
 131   1          if ( key.time < KEY_TIME ) { key.time++; }
 132   1      
 133   1          if ( state.time < STATE_TIME ) { state.time++; }
 134   1      
 135   1          if ( sonic.time < SONIC_TIME ) { sonic.time++; }
 136   1      
 137   1          if ( ADC_time < ADC_TIME ) { ADC_time++; }
 138   1          
 139   1          if ( shan_time < SHAN_TIME ) { shan_time++; }
 140   1      }
 141          
 142          void key_proc()
 143          {   
 144   1          
 145   1          key.press = key_scan();
 146   1          
 147   1          switch (key.press)
 148   1          {
 149   2              case 4:
 150   2              {
 151   3                  state.mode_1 = (state.mode_1 + 1) % 3;
 152   3                  led_state();
 153   3              }
 154   2              break;
 155   2      
 156   2              case 5:
 157   2              {
 158   3                  if (state.mode_1 == 1)
 159   3                      { state.mode_2 = (state.mode_2 + 1) % 2; }
 160   3                      
 161   3              }
 162   2              break;
 163   2      
 164   2              case 8:
 165   2              {
 166   3                  if (state.mode_1 == 1 && state.mode_2 == 0)
 167   3                  {
 168   4                      argument.high_value = argument.high_value + 10;
 169   4                      if (argument.high_value > 90)
 170   4                      {
 171   5                          argument.high_value = 50;
 172   5                      }
 173   4                  }
 174   3                  else if (state.mode_1 == 1 && state.mode_2 == 1)
 175   3                  {
 176   4                      led_value[7] = 0;
 177   4                      state.check_mode2 = 0;
 178   4                      ADC_proc();
C51 COMPILER V9.60.7.0   MAIN                                                              04/01/2025 17:23:36 PAGE 4   

 179   4                  }
 180   3              }
 181   2              break;
 182   2      
 183   2              case 9:
 184   2              {
 185   3                  if (state.mode_1 == 1 && state.mode_2 == 0)
 186   3                  {
 187   4                      argument.low_value = argument.low_value - 10;
 188   4                      if (argument.low_value < 0)
 189   4                      {
 190   5                          argument.low_value = 40;
 191   5                      }
 192   4                  }
 193   3                  else if (state.mode_1 == 1 && state.mode_2 == 1)
 194   3                  {
 195   4                      led_value[7] = 1;
 196   4                      state.check_mode2 = 1;
 197   4                      ADC_proc();
 198   4                  }
 199   3              }
 200   2              break;
 201   2          }
 202   1      }
 203          
 204          void state_proc()
 205          {
 206   1          switch (state.mode_1)
 207   1          {
 208   2              // 测距
 209   2              case 0:
 210   2              {
 211   3                  if (state.one_flag != 0)
 212   3                  {
 213   4                      state.one_flag = 0; 
 214   4                      seg[0] = 43; seg[1] = 16; seg[2] = 16; seg[3] = 16; seg[4] = 16;
 215   4                  }
 216   3                  
 217   3                  seg[5] = sonic.list[0];
 218   3                  seg[6] = sonic.list[1];
 219   3                  seg[7] = sonic.list[2];
 220   3              }
 221   2              break;
 222   2      
 223   2              // 参数
 224   2              case 1:
 225   2              {
 226   3                  if (state.one_flag != 1)
 227   3                  {
 228   4                      state.one_flag = 1;
 229   4                      seg[0] = 24; seg[2] = 16; seg[5] = 17;
 230   4                  }
 231   3      
 232   3                  seg[1] = state.mode_2 + 1;
 233   3      
 234   3                  seg[3] = argument.low_value / 10 % 10;
 235   3                  seg[4] = argument.low_value % 10;
 236   3      
 237   3                  seg[6] = argument.high_value / 10 % 10;
 238   3                  seg[7] = argument.high_value % 10;
 239   3              }
 240   2              break;
C51 COMPILER V9.60.7.0   MAIN                                                              04/01/2025 17:23:36 PAGE 5   

 241   2      
 242   2              // 记录界面
 243   2              case 2:
 244   2              {
 245   3                  if (state.one_flag != 2)
 246   3                  {
 247   4                      state.one_flag = 2; 
 248   4                      seg[0] = 14; 
 249   4                      seg[1] = 16; seg[2] = 16; seg[3] = 16; 
 250   4                      seg[4] = 16; seg[5] = 16; seg[6] = 16;
 251   4                  }
 252   3                  seg[7] = argument.out_times;
 253   3              }
 254   2              break;
 255   2          }
 256   1      }
 257          
 258          
 259          void sonic_proc()
 260          {
 261   1          sonic.distance = sonic_measure();
 262   1      
 263   1          sonic.list[0] = sonic.distance / 100 % 10;
 264   1          sonic.list[1] = sonic.distance / 10 % 10;
 265   1          sonic.list[2] = sonic.distance % 10;
 266   1      
 267   1          delete_0(sonic.list, 3, 0);
 268   1      
 269   1          //adjust_out();
 270   1      }
 271          
 272          void ADC_proc()
 273          {
 274   1        uchar value;
 275   1        
 276   1          ADC_value = ADC(0x03);
 277   1          //led_value[0] = 1;
 278   1      
 279   1          if (ADC_value <= 51)
 280   1          {
 281   2              value = 50; 
 282   2          }
 283   1          else if (51 < ADC_value && ADC_value <= 102)
 284   1          {
 285   2              value = 60;
 286   2          }
 287   1          else if (102 < ADC_value && ADC_value <= 153)
 288   1          {
 289   2              value = 70;
 290   2          }
 291   1          else if (154 < ADC_value && ADC_value <= 205)
 292   1          {
 293   2              value = 80;
 294   2          }
 295   1          else if (205 < ADC_value && ADC_value <= 255)
 296   1          {
 297   2              value = 90;
 298   2          }
 299   1      
 300   1          if (state.check_mode2 == 0)
 301   1          {
 302   2              argument.low_value = value - 50;
C51 COMPILER V9.60.7.0   MAIN                                                              04/01/2025 17:23:36 PAGE 6   

 303   2          }
 304   1          else if (state.check_mode2 == 1)
 305   1          {
 306   2              argument.high_value = value;
 307   2          } 
 308   1      
 309   1          value = 0;
 310   1      }
 311          
 312          
 313          void led_state()
 314          {
 315   1          led_value[0] = 0;
 316   1          led_value[1] = 0;
 317   1          led_value[2] = 0;
 318   1      
 319   1          led_value[state.mode_1] = 1;
 320   1      
 321   1      
 322   1          // uchar i;
 323   1          // for (i = 0;i < 3;i++)
 324   1          // {
 325   1          //     if (i != state.mode_1)
 326   1          //     {
 327   1          //         led_value[i] = 0;
 328   1          //     }
 329   1          //     else
 330   1          //     {
 331   1          //         led_value[i] = 1;
 332   1          //     }
 333   1          // }
 334   1      }
 335          
 336          
 337          void adjust_out()
 338          {
 339   1          static uchar adjust;
 340   1          if (argument.low_value <= sonic.distance && sonic.distance <= argument.high_value)
 341   1          {
 342   2              adjust = 1;
 343   2              led_value[7] = 1;
 344   2          }
 345   1          else 
 346   1          {
 347   2              led_value[7] = shan_flag;
 348   2              if (adjust == 1)
 349   2              {
 350   3                  if (argument.out_times < 10)
 351   3                      argument.out_times++;
 352   3                  else
 353   3                      argument.out_times = 17;
 354   3                  
 355   3                  adjust = 0;
 356   3              }
 357   2          }
 358   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    843    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              04/01/2025 17:23:36 PAGE 7   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
