# 点亮LED灯

初步学习单片机的第一步，就是点亮一颗LED灯。让我们来一起尝试一下吧。

我们先把项目创建好后，就来写代码操作单片机吧。

首先我们来看如何写。

点亮LED灯，只需要在LED灯的正极加上3.3V的电压，负极接地，即可点亮。

来看看我们的硬件原理图。

## 74HC573

![image-20250927133133263](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/image-20250927133133263.png)

这里一共有8个LED灯，他们负极接到了74HC573的引脚上，正极加上限流电阻，接到5V的电源。

那么，我们只需要让负极与地相连，即可点亮LED灯。

我们来看看`74JC573`的数据手册，来了解如何将12到19管脚设置为低电平，从而点亮LED灯。

> 74HC573与74HCT573是一款基于硅栅CMOS工艺的高速器件，其引脚与低功耗肖特基TTL（LSTTL）兼容。该器件包含八个D型透明锁存器，每个锁存器均配备独立的D型输入端口，并采用适用于总线应用的三态真值输出。所有锁存器共享一个锁存使能（LE）输入端和一个输出使能（OE）输入端。
>
> 当LE处于高电平时，Dn输入端的数据将进入锁存器。在此状态下，锁存器呈透明模式，即锁存器输出会随其对应D输入端的状态变化而实时改变。
>
> 当LE转为低电平时，锁存器将存储LE由高电平向低电平跳变前一个建立周期时D输入端的数据。若OE为低电平，八个锁存器的内容将呈现在输出端；若OE为高电平，输出端则进入高阻抗关闭状态。需注意的是，OE输入端的操作不会影响锁存器的内部状态。

`74HC573`是一颗锁存器芯片，它有20个引脚，10号和20号引脚为电源，2-9号引脚为输入端，12-19号引脚为输出端。1号OE和11号LE引脚为控制引脚。

LE引脚是模式切换引脚，高电平时为透明模式，低电平时，如果OE引脚为高电平，则输出引脚为高阻态关闭状态，低电平时，8个输入引脚会呈现在输出引脚上。

![QQ_1758952074717](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/QQ_1758952074717.png)

在原理图中，OE引脚接地，则LE为低电平时，输出引脚的电平等于输入引脚。

**为了点亮LED灯，我们需要控制输入引脚为低电平，LE引脚再由高电平切换为低电平。**

让我们继续探索。输入引脚连接在单片机的P0口上：

![QQ_1758952763497](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/QQ_1758952763497.png)

## 74HC02

Y4C连接在了`74HC02`芯片上，这是一颗NOR(或门)芯片。先取或，再取反。

![QQ_1758952942382](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/QQ_1758952942382.png)

取或的意思是，如果两个输入端只要有一个为高电平，就输出高电平，否则，也就是输入端都为低电平，输出低电平。

取反的意思是，将如果输入是高电平，输出就是低电平。输入是低电平，输出就是高电平。

结合一起列出真值表：

| A    | B    | 输出 Y = ¬(A + B) |
| ---- | ---- | ----------------- |
| 0    | 0    | 1                 |
| 0    | 1    | 0                 |
| 1    | 0    | 0                 |
| 1    | 1    | 0                 |

我们来看原理图，这个芯片有5路NOR门，每个门的其中一个引脚接地，为低电平。

那么这时候，输入为1，输出为0，输入为0，输出为1，成为了一个取反的芯片。

为了控制`Y4C`由高电平切换成低电平，我们需要将`Y4`由低电平切换为高电平。

## 74HC138

![QQ_1758953891530](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/QQ_1758953891530.png)

> 74HC138 解码器采用先进的硅栅 CMOS 工艺，适用于存储器地址解码或数据分配应用。该电路具有 CMOS 电路通常具备的高抗噪声能力和低功耗，同时速度可与低功耗肖特基 TTL 逻辑相媲美。
>
> 74HC138 具有 3 个二进制选择输入（A、B 和 C）。当器件被使能时，这些输入决定 8 个通常保持高电平的输出端中哪一个会被拉低。器件提供了两个低有效和一个高有效的使能端（G1、G2A 和 G2B），方便实现译码器的级联。

数据手册里有芯片的真值表：

![QQ_1758954577525](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/QQ_1758954577525.png)

![QQ_1758954720021](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/QQ_1758954720021.png)

在数据手册中，G1是6号引脚，G2B为5号引脚，G2A为4号引脚，

G2A -> E1

G2B -> E2

G1 -> E3

我们来看原理图，E1、E2接地，都为低电平，E3为高电平。G2为低电平，G1为高电平，在真值表中是3到10行。我们配置1到3号引脚的电平，组成2^3=8个组合，能依次设置输出的8个引脚的其中一个为低电平。

我们要使Y4为低电平，就要设置A0为低电平，A1为低电平，A2为高电平。

![QQ_1758955723512](./%E7%82%B9%E4%BA%AElED%E7%81%AF.assets/QQ_1758955723512.png)



| P0.7 | P0.6 | P0.5 | P0.4 | P0.3 | P0.2 | P0.1 | P0.0 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| b7   | b6   | b5   | b4   | b3   | b2   | b1   | b0   |

我们先进行或运算，将设置P25到P27为低电平，再进行与运算，配置为100。

```c
P2 = (P2 & 0x1F) | 0x80;
// 0x1F -> 0001 1111
// 0x80 -> 1000 0000
```

这样即可。

综上，我们的流程是：

1. 设置P0 为低电平
2. P2配置成 1000 xxxx

即可完成点灯。

让我们来写代码吧。

```c
#include "stc15f2k60s2.h"

int main()
{
    P0 = ~0x01;
    P2 = (P2 & 0x1F) | 0x80;
    P2 = P2 & 0x1F;
    while(1);
}
```

