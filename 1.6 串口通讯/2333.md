以下是针对STC单片机（以1T模式为例）串口配置的详细解析，结合您提供的代码进行分步说明：

---

### **一、串口配置核心寄存器解析**
#### **1. SCON (Serial Control Register) - 串口控制寄存器**
```c
SCON = 0x50;  // 二进制 0101 0000
```
- **位7 (SM0)**: `0`  
- **位6 (SM1)**: `1` → **工作模式1** (8位UART，波特率可变)
- **位5 (SM2)**: `0` → 禁止多机通信模式
- **位4 (REN)**: `1` → **允许接收数据**
- 其他位保持默认值0。

#### **2. AUXR (Auxiliary Register) - 辅助寄存器**
```c
AUXR |= 0x01;  // 二进制 0000 0001
AUXR |= 0x04;  // 二进制 0000 0100
```
- **位0 (S1ST2)**: `1` → 串口1使用**定时器2**作为波特率发生器（传统8051使用定时器1）
- **位2 (T2x12)**: `1` → 定时器2时钟为**1T模式**（时钟不分频）

---

### **二、波特率计算原理**
#### **1. 公式推导**
波特率计算公式为：
\[
\text{波特率} = \frac{\text{Fosc}}{16 \times (65536 - \text{T2H:T2L})}
\]
其中：
- **Fosc** = 主频（代码中为12MHz）
- **T2H:T2L** = 定时器2的初值（16位）

#### **2. 代码错误分析**
原代码：
```c
T2L = 0x8F;  // 低字节 0x8F
T2H = 0xFD;  // 高字节 0xFD
```
- **初值** = `0xFD8F` = 64911（十进制）
- **实际波特率**：
  \[
  \frac{12,000,000}{16 \times (65536 - 64911)} = \frac{12,000,000}{16 \times 625} = 1200 \, \text{bps}
  \]
  **与目标4800bps相差4倍**。

#### **3. 修正后的计算**
目标波特率 **4800bps**：
\[
\text{初值} = 65536 - \frac{12,000,000}{16 \times 4800} = 65536 - 156.25 = 65379.75 \approx 65380
\]
- **十六进制**：`0xFF64`
- **正确赋值**：
  ```c
  T2H = 0xFF;  // 高字节
  T2L = 0x64;  // 低字节
  ```

---

### **三、完整配置流程**
#### **1. 初始化步骤**
1. **设置串口模式**：`SCON = 0x50` → 模式1，允许接收。
2. **选择定时器2**：`AUXR |= 0x01` → 串口1绑定定时器2。
3. **配置1T模式**：`AUXR |= 0x04` → 定时器2时钟不分频。
4. **设置波特率初值**：`T2H`和`T2L`写入计算后的初值。
5. **启动定时器2**：`AUXR |= 0x10` → 定时器2开始计数。
6. **开启中断**：`ES = 1` → 允许串口中断。

#### **2. 关键代码修正**
```c
void UartInit(void) {  // 4800bps@12.000MHz
    SCON = 0x50;       // 模式1，允许接收
    AUXR |= 0x01;      // 串口1使用定时器2
    AUXR |= 0x04;      // 定时器2为1T模式
    
    // 波特率初值计算（4800bps）
    #define FOSC 12000000UL
    #define BAUD 4800
    uint16_t timer2_reload = 65536 - (FOSC / (16 * BAUD));
    
    T2H = (timer2_reload >> 8);  // 高字节 0xFF
    T2L = timer2_reload & 0xFF;  // 低字节 0x64
    
    AUXR |= 0x10;      // 启动定时器2
    ES = 1;            // 开启串口中断
}
```

---

### **四、验证与调试建议**
#### **1. 波特率验证**
- **示波器测量**：检测TXD引脚波形，计算位周期是否为208.3μs（对应4800bps）。
- **串口助手测试**：发送固定数据（如0x55，二进制01010101），观察接收是否正确。

#### **2. 常见问题**
- **误差过大**：检查主频是否准确（如12MHz晶振是否起振）。
- **数据乱码**：确认发送端和接收端的波特率、数据位、停止位一致。
- **无法进入中断**：检查中断服务函数是否实现，并正确声明：
  ```c
  void Uart_Isr(void) interrupt 4 {
      if (RI) {
          RI = 0;  // 处理接收数据
      }
      // 其他处理...
  }
  ```

---

### **五、扩展知识**
#### **1. 1T vs 12T模式**
- **1T模式**：定时器每个机器周期计数1次（STC单片机增强特性）。
- **12T模式**：传统8051模式，每个机器周期计数12次。
- **影响**：1T模式波特率计算时需使用更高的初值。

#### **2. 其他波特率配置**
| 目标波特率 | 初值（1T模式） | T2H | T2L |
|------------|----------------|-----|-----|
| 9600bps    | 64896 (0xFD80) | 0xFD| 0x80|
| 115200bps  | 65408 (0xFF80) | 0xFF| 0x80|

---

通过以上配置，串口可以稳定工作在4800bps，确保数据收发正确。实际项目中还需注意硬件连接（如电平转换芯片MAX232）和软件协议设计（如校验位、帧头帧尾）。